diff --git a/.gitignore b/.gitignore
index bba168a..20808d7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,6 @@
 ï»¿venv/
 
+.env
 cache
 client.session
 client.session-journal
diff --git a/.python-version b/.python-version
new file mode 100644
index 0000000..c8cfe39
--- /dev/null
+++ b/.python-version
@@ -0,0 +1 @@
+3.10
diff --git a/cleaner.py b/cleaner.py
index befaaa3..db909fa 100644
--- a/cleaner.py
+++ b/cleaner.py
@@ -1,5 +1,6 @@
 import os
 import json
+# import asyncio
 
 from time import sleep
 
@@ -24,7 +25,6 @@ else:
     API_HASH = os.getenv('API_HASH', None) or input('Enter your Telegram API hash: ')
 
 app = Client("client", api_id=API_ID, api_hash=API_HASH)
-app.start()
 
 if not os.path.exists(cachePath):
     with open(cachePath, "w") as cacheFile:
@@ -53,19 +53,16 @@ class Cleaner:
             yield l[i:i + n]
 
     @staticmethod
-    def get_all_chats():
-        dialogs = app.get_dialogs(pinned_only=True)
+    async def get_all_chats():        
+        async with app:
+            dialogs = []
+            async for dialog in app.get_dialogs():
+                dialogs.append(dialog.chat)
+            return dialogs
 
-        dialog_chunk = app.get_dialogs()
-        while len(dialog_chunk) > 0:
-            dialogs.extend(dialog_chunk)
-            dialog_chunk = app.get_dialogs(offset_date=dialogs[-1].top_message.date-1)
-
-        return [d.chat for d in dialogs]
-
-    def select_groups(self, recursive=0):
-        chats = self.get_all_chats()
-        groups = [c for c in chats if c.type in ('group', 'supergroup')]
+    async def select_groups(self, recursive=0):
+        chats = await self.get_all_chats()
+        groups = [c for c in chats if c.type.name in ('GROUP, SUPERGROUP')]
 
         print('Delete all your messages in')
         for i, group in enumerate(groups):
@@ -101,60 +98,81 @@ class Cleaner:
         if recursive == 1:
             self.run()
 
-    def run(self):
+    async def run(self):
         for chat in self.chats:
-            peer = app.resolve_peer(chat.id)
+            chat_id = chat.id
             message_ids = []
             add_offset = 0
 
             while True:
-                q = self.search_messages(peer, add_offset)
-                message_ids.extend(msg.id for msg in q['messages'])
-                messages_count = len(q['messages'])
-                print(f'Found {messages_count} of your messages in "{chat.title}"')
+                q = await self.search_messages(chat_id, add_offset)
+                message_ids.extend(msg.id for msg in q)
+                messages_count = len(q)
+                print(f'Found {len(message_ids)} of your messages in "{chat.title}"')
                 if messages_count < self.search_chunk_size:
                     break
                 add_offset += self.search_chunk_size
 
-            self.delete_messages(chat.id, message_ids)
+            await self.delete_messages(chat_id=chat.id, message_ids=message_ids)
 
-    def delete_messages(self, chat_id, message_ids):
+    async def delete_messages(self, chat_id, message_ids):
         print(f'Deleting {len(message_ids)} messages with message IDs:')
         print(message_ids)
         for chunk in self.chunks(message_ids, self.delete_chunk_size):
             try:
-                app.delete_messages(chat_id=chat_id, message_ids=chunk)
+                async with app:
+                    await app.delete_messages(chat_id=chat_id, message_ids=chunk)
             except FloodWait as flood_exception:
                 sleep(flood_exception.x)
 
-    def search_messages(self, peer, add_offset):
-        print(f'Searching messages. OFFSET: {add_offset}')
-        return app.send(
-            Search(
-                peer=peer,
-                q='',
-                filter=InputMessagesFilterEmpty(),
-                min_date=0,
-                max_date=0,
-                offset_id=0,
-                add_offset=add_offset,
-                limit=self.search_chunk_size,
-                max_id=0,
-                min_id=0,
-                hash=0,
-                from_id=InputPeerSelf()
-            ),
-            sleep_threshold=60
-        )
 
-
-if __name__ == '__main__':
+    async def search_messages(self, chat_id, add_offset):
+        async with app:
+            messages = []
+            print(f'Searching messages. OFFSET: {add_offset}')
+            async for message in app.search_messages(chat_id=chat_id, offset=add_offset, from_user="me", limit=100):
+                messages.append(message)
+            return messages
+
+async def delete_reactions(chat_id):
+    async with app:
+        me = await app.get_me()
+        print(f'me.id: {me.id}')
+        async for message in app.get_chat_history(chat_id):
+            # print(f'checking message id: {message.message_id}')
+            if message.reactions:
+                print(f'{message.id} has reactions')
+                if message.from_user.id == me.id:
+                    print(f'deleting {message.reactions} on message.message_id')
+                    # Delete the original message
+                    await app.delete_messages(chat_id, message.message_id)
+
+                    # Resend the message without reactions
+                    await app.send_message(chat_id, message.text)
+            # await asyncio.sleep(1)
+
+async def list_chats():
+    async with app:
+        dialogs = []
+        async for dialog in app.get_dialogs():
+            # chat = dialog.chat
+            dialogs.append(dialog.chat)
+            # print(f"Chat ID: {chat.id}, Title: {chat.title or chat.first_name or chat.username}")
+        groups = [c for c in dialogs if c.type.name in ('GROUP, SUPERGROUP')]
+        for g in groups:
+            print(f' {g.id} - {g.title}')
+
+async def main():
     try:
+        # app.run(await list_chats())
+        # asyncio.run(await delete_reactions("-656476951"))
+        # asyncio.get_event_loop().run_until_complete(await delete_reactions("-656476951"))
         deleter = Cleaner()
-        deleter.select_groups()
-        deleter.run()
+        await deleter.select_groups()
+        await deleter.run()
     except UnknownError as e:
         print(f'UnknownError occured: {e}')
         print('Probably API has changed, ask developers to update this utility')
-    finally:
-        app.stop()
+
+# asyncio.run(delete_reactions("-656476951"))
+app.run(main())
diff --git a/requirements.txt b/requirements.txt
index 2cbc440..92e7b60 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,2 +1,3 @@
-pyrogram==1.4
-tgcrypto # Optional, for faster cleaning. You could remove this line
\ No newline at end of file
+telethon==1.36.0
+pyrogram==2.0.106
+tgcrypto # Optional, for faster cleaning. You could remove this line
diff --git a/rm_reactions.py b/rm_reactions.py
new file mode 100644
index 0000000..b0722f2
--- /dev/null
+++ b/rm_reactions.py
@@ -0,0 +1,100 @@
+import os
+import argparse
+
+from telethon.sync import TelegramClient
+from telethon.tl.types import Channel, Chat, PeerUser
+
+from pyrogram.client import Client
+
+
+API_ID = os.getenv('API_ID', None) or int(input('Enter your Telegram API id: '))
+API_HASH = os.getenv('API_HASH', None) or input('Enter your Telegram API hash: ')
+
+session_name='rm_reactions'
+client = TelegramClient(session_name, API_ID, API_HASH)
+app = Client(session_name, api_id=API_ID, api_hash=API_HASH)
+
+async def rm_reaction(app, chat_id, msg_id):
+    try:
+        await app.send_reaction(chat_id, msg_id)
+    except Exception as e:
+        print("Failed to remove reaction:", e)
+
+async def main():
+    async with app:
+        parser = argparse.ArgumentParser(description="Process some flags.")
+        parser.add_argument('-l', '--list', action='store_true', help='list chats with reactions but do not delete')
+
+        args = parser.parse_args()
+
+        me = await client.get_me()
+        # print(f"me.id: {me.id}")
+
+        dialogs = await client.get_dialogs()
+        groups = []
+        
+        for dialog in dialogs:
+            entity = dialog.entity
+            if isinstance(entity, Chat) or (isinstance(entity, Channel) and entity.megagroup):
+                groups.append(dialog)
+
+        if not groups:
+            print("No groups found.")
+            return
+
+        print(f"Available groups({len(groups)}):")
+        for i, group in enumerate(groups):
+            print(f"{i}. {group.name}")
+        print(f"{len(groups)}. ALL GROUPS")
+
+        selected_group_indexs = input("Select one or many groups by entering their indexes comma separated: ")
+
+        str_list = selected_group_indexs.split(',')
+        int_list = [int(num.strip()) for num in str_list]
+
+        groups_to_process = []
+        if len(int_list) == 1 and selected_group_indexs[0] == len(groups):
+            groups_to_process = groups
+        else:
+            for i in int_list:
+                groups_to_process.append(groups[i])
+
+        print(f"\nGroups to Process:")
+        for g in groups_to_process:
+            print(f"\t{g.name}")
+
+
+        for g in groups_to_process:
+            print(f"\nProcessing {g.name}")
+            count = await rm_reactions_from_chat(app, g.id, me, not args.list)
+            if args.list:
+                print(f"{g.name} has {count} reactions")
+            else:
+                print(f"Removed {count} reactions from {g.name}")
+
+
+async def rm_reactions_from_chat(app, chat_id, me, rm: bool = False):
+    reactionCount = 0
+    numMessages = await app.get_chat_history_count(chat_id)
+    i = 0
+    async for message in client.iter_messages(chat_id):
+        print(f"Progress: {i + 1}/{numMessages} ({(i + 1) / numMessages * 100:.2f}%)", end='\r')
+        if message.reactions:
+            # print(f'message.reactions: {message.reactions}')
+            recent_reactions = message.reactions.recent_reactions
+            if recent_reactions == None:
+                continue
+            for reaction in recent_reactions:
+                user = reaction.peer_id
+                # print(f"comparing me.id: {me.id} and user: {user}")
+                if isinstance(user, PeerUser) and me.id == user.user_id:
+                    # print(f"User {user} reacted with {reaction.reaction} to post message_id: {message.id}: {message.text}.")
+                    if rm:
+                        await rm_reaction(app, chat_id, message.id)
+                        print(f"Removed reaction on msg_id: {message.id}")
+                    reactionCount+=1
+        i += 1
+    return reactionCount
+
+with client:
+    client.loop.run_until_complete(main())
